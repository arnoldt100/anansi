# The foundational style.
--style=allman

# Force an indentation of 4 spaces.
--indent=spaces=4

# Indent 'switch' blocks so that the 'case X:' statements are indented in the
# switch block. The entire case block is indented.
--indent-switches

# Indent 'class' and 'struct' blocks so that the entire block is indented. The
# struct blocks are indented only if an access modifier, 'public:',
# 'protected:' or 'private:', is declared somewhere in the struct. This option
# is effective for C++ files only.
--indent-classes

# Indent preprocessor conditional statements to the same level as the source
# code.
--indent-preproc-cond

# Indent preprocessor blocks at brace level zero and immediately within a
# namespace. There are restrictions on what will be indented. Blocks within
# methods, classes, arrays, etc., will not be indented. Blocks containing
# braces or multi-line define statements will not be indented. Without this
# option the preprocessor block is not indented.
--indent-preproc-block

# Set the minimal indent that is added when a header is built of multiple lines.
# This indent helps to easily separate the header from the command statements
# that follow. The value for # indicates a number of indents and is a minimum
# value. The indent may be greater to align with the data on the previous line.
# The valid values are:
# 0 - no minimal indent. The lines will be aligned with the paren on the preceding line.
# 1 - indent at least one additional indent.
# 2 - indent at least two additional indents.
# 3 - indent at least one-half an additional indent. This is intended for large indents (e.g. 8).
--min-conditional-indent=0

# Add one line braces to unbraced one line conditional statements (e.g. 'if',
# 'for', 'while'...). The statement must be on a single line. The option
# implies --keep-one-line-blocks and will not break the one line blocks.
--add-one-line-braces

# Break the return type from the function name. The two options are for the
# function definitions (-xB), and the function declarations or signatures
# (-xD).
--break-return-type
--break-return-type-decl 

# The option max‑code‑length will break a line if the code exceeds #
# characters. The valid values are 50 thru 200. Lines without logical
# conditionals will break on a logical conditional (||, &&, ...), comma, paren,
# semicolon, or space.
#
# Some code will not be broken, such as comments, quotes, and arrays. If used
# with keep‑one‑line‑blocks or add-one-line-braces the blocks will NOT be
# broken. If used with keep‑one‑line‑statements the statements will be broken
# at a semicolon if the line goes over the maximum length. If there is no
# available break point within the max code length, the line will be broken at
# the first available break point after the max code length.
#
# By default logical conditionals will be placed first in the new line. The
# option break‑after‑logical will cause the logical conditionals to be placed
# last on the previous line. This option has no effect without max‑code‑length.
--max-code-length=120
--break-after-logical
